# AVL 트리 구현
우선 `BinarySearch.h`와 `BinarySearch.c`에 다음과 같은 문장을 추가해줘야 한다.   
이진 탐색 트리의 삽입 연산 후에 리밸런싱, 삭제 연산 후에 리밸런싱을 해주도록 하는 것이다.
```c
void BSTInsert(BTreeNode** pRoot, BSTData data)
{
    ...

    *pRoot = Rebalance(pRoot); // 노드 추가 후 리밸런싱!
}

BTreeNode* BSTRemove(BTreeNode** pRoot, BSTData target)
{
    ...

    *pRoot = Rebalance(pRoot); // 노드 제거 후 리밸런싱!
    return dNode; // 삭제 대상의 반환
}
```

## LL연산
네가지 연산 중 대표로 LL연산을 설명하고자 한다.
```c
// LL회전
BTreeNode* RotateLL(BTreeNode* bst)
{
	BTreeNode* pNode; // parent node
	BTreeNode* cNode; // child node
	
	// pNode와 cNode가 LL회전을 위해 적절한 위치를 가리키게 한다.
	pNode = bst;
	cNode = GetLeftSubTree(pNode);

	// 실제 LL회전을 담당하는 두 개의 문장
	ChangeLeftSubTree(pNode, GetRightSubTree(cNode));
	ChangeRightSubTree(cNode, pNode);

	// LL회전으로 인해서 변경된 루트 노드의 주소 값 반환
	return cNode;
}
```
위의 코드에서 아래 부분을 그림으로 설명하면 다음과 같다.
```c
ChangeLeftSubTree(pNode, GetRightSubTree(cNode));
ChangeRightSubTree(cNode, pNode);
```
![image](https://github.com/user-attachments/assets/9da3459a-a728-490a-8705-091b5b57a6c2)

# Code
### AVLRebalance.h
```c
#ifndef __AVL_REBALANCE_H__
#define __AVL_REBALANCE_H__

#include "BinaryTree.h"

// 트리의 균형을 잡는다.
BTreeNode* Rebalance(BTreeNode** pRoot);

#endif
```

### AVLRebalance.c
```c
#include <stdio.h>
#include "BinaryTree.h"

// LL회전
BTreeNode* RotateLL(BTreeNode* bst)
{
	BTreeNode* pNode; // parent node
	BTreeNode* cNode; // child node
	
	// pNode와 cNode가 LL회전을 위해 적절한 위치를 가리키게 한다.
	pNode = bst;
	cNode = GetLeftSubTree(pNode);

	// 실제 LL회전을 담당하는 두 개의 문장
	ChangeLeftSubTree(pNode, GetRightSubTree(cNode));
	ChangeRightSubTree(cNode, pNode);

	// LL회전으로 인해서 변경된 루트 노드의 주소 값 반환
	return cNode;
}

// RR회전
BTreeNode* RotateRR(BTreeNode* bst)
{
	BTreeNode* pNode; // parent node
	BTreeNode* cNode; // child node

	// pNode와 cNode가 RR회전을 위해 적절한 위치를 가리키게 한다.
	pNode = bst;
	cNode = GetRightSubTree(pNode);

	// 실제 RR회전을 담당하는 두 개의 문장
	ChangeRightSubTree(pNode, GetRightSubTree(cNode));
	ChangeLeftSubTree(cNode, pNode);

	// RR회전으로 인해서 변경된 루트 노드의 주소 값 반환
	return cNode;
}

// LR회전
BTreeNode* RotateLR(BTreeNode* bst)
{
	BTreeNode* pNode;  // parent node
	BTreeNode* cNode;  // child node

	// pNode와 cNode가 LR회전을 위해 적절한 위치를 가리키게 한다.
	pNode = bst;
	cNode = GetLeftSubTree(pNode);

	// 실제 LR회전을 담당하는 두 개의 문장
	ChangeLeftSubTree(pNode, RotateRR(cNode)); // 부분적 RR회전
	return RotateLL(pNode);                    // LL회전
}

// RL회전
BTreeNode* RotateRL(BTreeNode* bst)
{
	BTreeNode* pNode;  // parent node
	BTreeNode* cNode;  // child node

	// pNode와 cNode가 RL회전을 위해 적절한 위치를 가리키게 한다.
	pNode = bst;
	cNode = GetRightSubTree(pNode);

	// 실제 RL회전을 담당하는 두 개의 문장
	ChangeRightSubTree(pNode, RotateLL(cNode)); // 부분적 LL회전
	return RotateRR(pNode);                     // RR회전
}

// 트리의 높이를 계산하여 반환
int GetHeight(BTreeNode* bst)
{
	int leftH;   // left height
	int rightH;  // right height

	if (bst == NULL)
		return 0;

	leftH = GetHeight(GetLeftSubTree(bst));   // 왼쪽 서브 트리 높이 계산
	rightH = GetHeight(GetRightSubTree(bst)); // 오른쪽 서브 트리 높이 계산

	// 큰 값의 높이를 반환한다.
	if (leftH > rightH)
		return leftH + 1;
	else
		return rightH + 1;
}

// 두 서브 트리의 '높이의 차(균형 인수)'를 반환
int GetHeightDiff(BTreeNode* bst)
{
	int lsh;  // left sub tree height
	int rsh;  // right sub tree height

	if (bst == NULL)
		return 0;

	lsh = GetHeight(GetLeftSubTree(bst));  // 왼쪽 서브 트리의 높이
	rsh = GetHeight(GetRightSubTree(bst)); // 오른쪽 서브 트리의 높이
	return lsh - rsh; // 균형 인수 계산결과 반환
}

// 트리의 균형을 잡는다.
BTreeNode* Rebalance(BTreeNode** pRoot)
{
	int hDiff = GetHeightDiff(*pRoot); // 균형 인수 계산

	// 균형 인수가 +2 이상이면 LL상태 또는 LR상태이다.
	if (hDiff > 1)  // 왼쪽 서브 트리 방향으로 높이가 2 이상 크다면,
	{
		if (GetHeight(GetLeftSubTree(*pRoot)) > 0)
			*pRoot = RotateLL(*pRoot);
		else
			*pRoot = RotateLR(*pRoot);
	}

	// 균형 인수가 -2 이하이면 RR상태 또는 RL상태이다.
	if (hDiff < -1)  // 오른쪽 서브 트리 방향으로 2 이상 크다면,
	{
		if (GetHeightDiff(GetRightSubTree(*pRoot)) < 0)
			*pRoot = RotateRR(*pRoot);
		else
			*pRoot = RotateRL(*pRoot);
	}

	return *pRoot;
}
```

### main.c
```c
#include <stdio.h>
#include "BinaryTree.h"	// 트리의 구조를 확인하기 위해서
#include "BinarySearchTree.h"

int main(void)
{
	BTreeNode* avlRoot;
	BTreeNode* clNode;		// current left node
	BTreeNode* crNode;		// current right node

	BTreeNode* clNode2;
	BTreeNode* crNode2;

	BTreeNode* clNode3;
	BTreeNode* crNode3;

	BSTMakeAndInit(&avlRoot);

	BSTInsert(&avlRoot, 1); BSTInsert(&avlRoot, 2);
	BSTInsert(&avlRoot, 3); BSTInsert(&avlRoot, 4);
	BSTInsert(&avlRoot, 5); BSTInsert(&avlRoot, 6);
	BSTInsert(&avlRoot, 7); BSTInsert(&avlRoot, 8);
	BSTInsert(&avlRoot, 9);

	printf("루트 노드: %d \n", GetData(avlRoot));    //4

	clNode = GetLeftSubTree(avlRoot);   //2, 루트 4의 왼편
	crNode = GetRightSubTree(avlRoot);  //6, 루트 4의 오른편
	printf("%d, %d \n", GetData(clNode), GetData(crNode));

	clNode2 = GetLeftSubTree(clNode);    //1, 2의 왼편
	crNode2 = GetRightSubTree(clNode);   //3, 2의 오른편
	printf("%d, %d \n", GetData(clNode2), GetData(crNode2));

	clNode2 = GetLeftSubTree(crNode);    //5, 3의 왼편
	crNode2 = GetRightSubTree(crNode);   //8, 3의 오른편
	printf("%d, %d \n", GetData(clNode2), GetData(crNode2));

	clNode3 = GetLeftSubTree(crNode2);   //7, 8의 왼편
	crNode3 = GetRightSubTree(crNode2);  //9, 8의 오른편
	printf("%d, %d \n", GetData(clNode3), GetData(crNode3));
	return 0;
}
```
```
출력결과

루트 노드: 4
2, 6
1, 3
5, 8
7, 9
```
