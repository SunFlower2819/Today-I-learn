'힙'은 ***완전 이진 트리***의 일종으로 배열을 기반으로 구현한다.   
***왜냐하면, 연결 리스트를 기반으로 힙을 구현하면, 새로운 노드를 힙의 '마지막 위치'에 추가하는 것이 쉽지 않기 때문이다.***

코드는 아래의 기준으로 짤 것이다.
* 힙은 완전 이진 트리이다.
* 힙의 구현은 배열을 기반으로 하며 인덱스가 0인 요소는 비워둔다.
* 따라서 힙에 저장된 노드의 개수와 마지막 노드의 고유번호는 일치한다.
* 노드의 고유번호가 노드가 저장되는 배열의 인덱스 값이 된다.
* 우선순위를 나타내는 정수 값이 작을수록 높은 우선순위를 나타낸다고 가정한다.


## 어떻게 완전 이진 트리의 노드가 단말 노드인 것을 알아낼 것인가..
힙은 완전 이진 트리이므로 오른쪽 자식 노드만 존재하는 상황은 발생하지 않는다.   
따라서 왼쪽 자식 노드가 없다면 자식 노드가 존재하지 않는 것으로 판단할 수 있다.   

> "자식 노드가 하나도 존재하지 않는 노드는 단말 노드이다."

단만 노드의 왼쪽 자식 노드의 인덱스 값은 힙에 저장된 노드의 수를 넘어서게 된다.   
단말 노드의 왼쪽 자식 노드는 존재하지 않기 때문이다.   
따라서 아래와 같은 코드로 자식 노드의 존재 유무를 알 수 있다.
```c
if (GetLChildIDX(idx) > ph->numOfData) // 자식 노드가 없다면 TRUE // (왼쪽 자식 노드의 인덱스) > (완전 이진 트리의 전체 노드 수)
  return 0;
```
예를 들면, 오직 하나의 루트 노드만 있는 완전 이진 트리가 있다고 가정했을 때, 왼쪽 자식 노드의 인덱스 번호는 2일 것이다.   
그리고 현재 하나의 노드만 트리에 존재하므로 트리의 전체 크기는 1일 것이다.      
즉 `2(왼쪽 자식 노드의 인덱스) > 1(현재 이진 트리의 크기)` 이므로 
현재 루트 노드에 자식이 하나도 없다는 것을 알 수 있다.
