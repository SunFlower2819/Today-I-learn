* 전위 순회(PreOrder Traversal): `루트 -> 왼쪽 -> 오른쪽`
* 중위 순회(Inorder Traversal): `왼쪽 -> 루트 -> 오른쪽`
* 후위 순회(Postorder Traversal): `왼쪽 -> 오른쪽 -> 루트`

반복적인 행위의 연속이므로 '재귀'를 활용한다.

참고로 노드의 방문목적은 데이터의 출력이 전부가 아니다(당연한 소리지만..😅).   
방문의 목적은 상황에 따라 달라진다.  
```
예를 들어, 서브트리를 완전히 제거해야하는 경우에는 반드시 후위 순회를 통해서 소멸을 진행해야 한다.   
루트 노드를 삭제하면 아래의 노드를 삭제하기가 힘들어지기 때문이다.
```
따라서 방문했을 때 할 일을 결정할 수 있도록, '함수 포인터'를 사용할 것이다.   
우리의 코드에서는 함수 포인터를 통해 ***노드의 데이터를 출력하는 역할***을 수행하도록 할 것이다.

위의 말을 이해하기 위해서 '함수 포인터'에 대한 이해를 하고 가보자.

# 함수 포인터 이해
```cpp
typedef void (*VisitFuncPtr)(BTData data); // 함수 포인터 정의

void PreorderTraverse(BTreeNode* bt, VisitFuncPtr action) // void PreorderTraverse(BTreeNode* bt, void (*action)(BTData data)) 와 동일
{
	if (bt == NULL)
		return;

	action(bt->data); // <-- action 함수에 bt->data를 전달해준다. 우리는 action()이 어떤 함수인지를 따로 정의해줄 필요가 있다. 즉, 어떤 action을 할지 우리가 정해줄 수 있다.
	PreorderTraverse(bt->left, action);
	PreorderTraverse(bt->right, action);
}
```
위와 같이 코드가 작성되어 있다.

우리는 `void (*VisitFcunPtr)(BTData data)`에 어떤 기능을 하는 함수를 전달해줄지 결정할 수 있다.  
만약 노드의 데이터가 짝수인 경우에만 출력하고 싶다면 아래와 같은 함수를 함수 포인터에 전달해주면 된다.

```c
void PrintIfEven(BTData data)
{
    if (data % 2 == 0)
        printf("%d ", data);
}

int main()
{
    // .. 코드 생략
    PreorderTraverse(bt, PrintIfEven); // 이진트리를 전위 순회하면서 짝수인 노드만 출력하기
}

✅PreorderTraverse(BTreeNode* bt, VisitFuncPtr action)에 PrintIfEven함수가 매개변수로 전달되면서,
   action(bt->data)는 PrintIfEven(bt->data)와 같은 의미를 가지게 된다.
```

***🎈🎈이렇게 함수 포인터를 사용하면 함수의 동작을 동적으로 전달하여 코드의 유연성을 높일 수 있다.***










