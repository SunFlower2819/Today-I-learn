### 🔵 이진 탐색(Binary Search) 알고리즘

이진 탐색 알고리즘을 적용하기 위해서는 다음의 조건을 만족해야 한다.
> **"배열에 저장된 데이터는 정렬되어 있어야 합니다."**


```c
#include <stdio.h>

int Bsearch(int ar[], int len, int target)
{
	int first = 0;       // 탐색 대상의 시작 인덱스 값
	int last = len - 1;  // 탐색 대상의 마지막 인덱스 값
	int mid;

	while (first <= last)
	{
		mid = (first + last) / 2;  // 탐색 대상의 중앙을 찾는다.

		if (ar[mid] == target)     // 중앙에 저장된 것이 타겟이라면
		{
			return mid;            // 탐색 완료!
		}
		else
		{
			if (target < ar[mid])   // 타겟이 아니라면 탐색 대상을 반으로 줄인다.
				last = mid - 1;     // 타겟이 중앙보다 왼쪽에 있다면 last를 중앙의 뒤로 옮긴다.
			else
				first = mid + 1;    // 타겟이 중앙보다 앞에 있다면 first를 중앙의 앞으로 옮긴다.
		}
	}
	return -1;
}

int main()
{
	int arr[] = { 1,3,5,7,9 };
	int idx;

	idx = Bsearch(arr, sizeof(arr) / sizeof(int), 7);
	if (idx == -1)
		printf("탐색 실패 \n");
	else
		printf("타겟 저장 인덱스: %d \n", idx);

	idx = Bsearch(arr, sizeof(arr) / sizeof(int), 4);
	if (idx == -1)
		printf("탐색 실패 \n");
	else
		printf("타겟 저장 인덱스: %d \n", idx);


	return 0;
}
```

> 출력결과
>> **타겟 저장 인덱스: 3 <br>
  탐색 실패**
  
  
---
### 🔵 이진 탐색 알고리즘의 시간 복잡도 계산하기: 최악의 경우(worst case)를 기준으로..

분석을 해보자.

* 8이 1이 되기까지 2로 나눈 횟수 3회, 따라서 비교연산 3회 진행
* 데이터가 1개 남았을 때, 이때 마지막으로 비교연산 1회 진행

이를 데이터의 수 $n$을 대상으로 다음과 같이 일반화를 할 수 있다.

* n이 1이 되기까지 2로 나눈 횟수 k회, 따라서 비교연산 k회 진행
* 데이터가 1개 남았을 때, 이때 마지막으로 비교연산 1회 진행

이로써 비교연산의 횟수를 구하였으니, 최악의 경우에 대한 시간 복잡도 함수 $T(n)$은 다음과 같이 정리가 된다.

* 최악의 경우에 대한 시간 복잡도 함수 : $T(n) = k + 1$


이제 k를 구하기 위해 n과 k에 관한 식을 다음과 같이 세울 수 있다.

> $n \times (\frac{1}{2})^k = 1$

이 수식은 2로 나누는 것은 1/2를 곱하는 것과 같다는 단순한 사실을 이용한 것이다. 2로 몇 번을 나누어야 1이 되는가에 대한 답을 준다.

따라서 $n = 2^k$을 도출할 수 있다.

그리고 $k$의 값을 구하기 위해서 양변에 $log$를 취하면 아래와 같은 수식이 나온다.

> $T(n)$ = $\log_{2}{(n)} + 1$ 

여기서 $+1$은 데이터 수의 증가에 따른 연산횟수의 변화 정도를 판단하는 것이므로 중요하지 않다.

따라서

> **$T(n)$ = $\log_{2}{(n)}$**

이 수식이 이진 탐색 알고리즘의 시간 복잡도가 되겠다.
