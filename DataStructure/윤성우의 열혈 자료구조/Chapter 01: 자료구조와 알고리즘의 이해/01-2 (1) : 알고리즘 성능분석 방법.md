시간 복잡도(time complexity) : 속도에 해당하는 알고리즘의 수행시간 분석결과
> 시간 복잡도는 **연산의 횟수**를 통하여 알고리즘의 빠르기를 판단한다.

공간 복잡도(space complexity) : 메모리 사용량에 대한 분석결과

---
```c
#include <stdio.h>

int LSearch(int ar[], int len, int target) // 순차 탐색 알고리즘
{
	int i;
	for (i = 0; i < len; i++)
	{
		if (ar[i] == target)
			return i;        // 찾은 대상의 인덱스 반환
	}
	return -1; // 못 찾으면 -1 반환
}


int main()
{
	int arr[] = { 3,5,2,4,9 };
	int idx;

	idx = LSearch(arr, sizeof(arr) / sizeof(int), 4);
	if (idx == -1)
		printf("탐색에 실패 \n");
	else
		printf("타겟 저장 인덱스: %d \n", idx);


	idx = LSearch(arr, sizeof(arr) / sizeof(int), 7);
	if (idx == -1)
		printf("탐색에 실패 \n");
	else
		printf("타겟 저장 인덱스: %d \n", idx);

	return 0;
}
```
위의 코드에서 **"어떤 연산을 적게 수행하는 탐색 알고리즘이 좋은 탐색 알고리즘일까?"**

바로 값의 동등을 비교하는 `==` 연산을 적게 수행하는 탐색 알고리즘이 좋은 탐색 알고리즘이다. 
즉, 탐색 알고리즘에서의 핵심은 동등비교를 하는 비교연산에 있다.

>🎈🎈 `==`연산을 적게 수행하는 것이 효율적인 것은 당연한 것이다. `==`을 한번만 수행했다는 것은 찾고자 하는 인덱스를 바로 찾았다는 뜻이니까.

비교연산의 수행횟수가 줄어들면 `<`연산과 `++`연산의 수행횟수도 줄어들고, 비교연산의 수행횟수가 늘어나면 `<`연산과 `++`연산의 수행횟수가 늘어난다. 
**결국 다른 연산들은 `==`연산에 의존적이다.**

따라서 우리는 `==`연산의 횟수를 대상으로 시간 복잡도를 분석하면 된다. 이렇듯 알고리즘의 시간 복잡도를 계산하기 위해서는 핵심이 되는 연산이 무엇인지
잘 판단해야 한다. 그리고 그 연산을 중심으로 시간 복잡도를 계산해야 한다.


