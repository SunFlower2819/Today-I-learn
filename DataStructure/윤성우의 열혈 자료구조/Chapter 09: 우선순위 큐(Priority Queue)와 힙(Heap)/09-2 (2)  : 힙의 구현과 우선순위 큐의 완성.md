### 👊삽입과 삭제의 과정에서 보인 성능의 평가

* 배열 기반 데이터 저장의 시간 복잡도      :      $O(n)$
* 배열 기반 데이터 삭제의 시간 복잡도      :      $O(1)$
  <br>  <br>
* 연결 리스트 기반 데이터 저장의 시간 복잡도 : $O(n)$
* 연결 리스트 기반 데이터 삭제의 시간 복잡도 : $O(1)$
  <br>  <br>
* 힙 기반 데이터 저장의 시간 복잡도 : $O(\log_2 n)$
* 힙 기반 데이터 삭제의 시간 복잡도 : $O(\log_2 n)$

---

### 👊힙의 구현에 어울리는 것은 연결 리스트? 아니면 배열?

우선순위 큐의 구현에 어울리는 것은 힙으로 결론을 냈다. <br>
그렇다면 이젠 힙의 구현방법에 대해서 고민해야 한다. 그런데 힙은 트리이다. <br>
따라서 앞에서 트리를 공부할 때 연결리스트로 구현을 했기에 어쩌면 힙의 구현 도구로도 연결리스트로 선택하면 될까?

하지만 아니다. 

생각과는 달리 완전 이진 트리의 구조를 갖고 또 그 구조를 유지해야 하는 '힙'은 배열을 기반으로 구현해야 한다. 그 이유는 다음과 같다.

"연결 리스트를 기반으로 힙을 구현하면, 새로운 노드를 힙의 '마지막 위치'에 추가하는 것이 쉽지 않다."

하지만 배열 기반의 힙이라면 이는 매우 간단한 문제가 된다.

🎈🎈따라서 힙과 같이, 새로운 노드를 추가한 이후에도 완전 이진 트리를 유지해야 하는 경우에는 연결 리스트가 아닌 배열을 기반으로 트리를 구현해야 한다. 
왜냐하면 새로운 노드를 추가할 때 완전 이진 트리를 유지하기 위해서는 노드를 **'마지막 위치'** 에 추가해야 하기 때문이다.

---

### 👊배열을 기반으로 힙을 구현하는데 필요한 지식들

1. 노드에 고유의 번호를 부여한다. 그리고 각 번호가 각 노드의 데이터가 저장 될 배열의 인덱스 값이 된다.
2. 인덱스가 0인 위치의 배열 요소는 사용하지 않는다. (고유의 번호를 매기기가 훨씬 쉬워진다.)

* 왼쪽 자식 노드의 인덱스 값 : 부모 노드의 인덱스 값 x 2
* 오른쪽 자식 노드의 인덱스 값 : 부모 노드의 인덱스 값 x 2 + 1
* 부모 노드의 인덱스 값 : 자식 노드의 인덱스 값 % 2

