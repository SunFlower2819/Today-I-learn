 '프로그램 코드라인 안으로 들어가 버린 함수'

   
 🟢 C언어의 매크로 함수

#include <stdio.h>

#define SQR(X) ((X)*(X)) // 매크로 함수는 이처럼 모든 인수를 괄호로 묶어줘야 함.
#define PRT(X) printf("계산 결과는 %d입니다.\n", X)  

int main(void)
{
    int result;
    int x = 5;  
 
    result = SQR(10);     // reuslt = 100;

    PRT(result);          // 100 출력

    result = SQR(x);      // result = 25;

    PRT(result);          // 25 출력

    result = SQR(x+3);    // result = 64;

    PRT(result);          // 64 출력

    return 0;
}

--------------------------------

✔ 매크로 함수의 장점

  1. 매크로 함수는 단순 치환만을 해주므로, 인수의 타입을 신경 쓰지 않습니다.

  2. 매크로 함수를 사용하면 여러 개의 명령문을 동시에 포함할 수 있습니다.

  3. 함수 호출에 의한 성능 저하가 일어나지 않으므로, 프로그램의 실행속도가 향상됩니다.
 
    --> 🎈🎈 이렇게 함수의 몸체부분이 함수호출 문장을 완전히 대체했을 때 "함수가 인라인화 되었다"라고 표현한다.
             (겉으로는 함수를 호출하는 것 처럼보여도 전처리 과정에서 그 부분이 몸체(코드)로 바뀐다.)

✔ 매크로 함수의 단점

  1. 원하는 결과를 얻는 정확한 매크로 함수의 구현은 어려우며, 따라서 디버깅 또한 매우 어렵습니다.

  2. 매크로 함수의 크기가 증가하면 증가할수록 사용되는 괄호 또한 매우 많아져서 가독성이 떨어집니다.
   
              
                                                                출처: http://www.tcpschool.com/c/c_prepro_macroFunc

🟢 C++ 기반의 인라인 함수 정의

 --> "C언어의 매크로 함수는 정의하기가 복잡하니, 일반 함수처럼 정의가 가능하면 좋겠다" 해서 등장한 것이 인라인 함수이다.
 
 
#include <iostream>

inline int SQUARE(int x)   // 🎈🎈 inline 키워드 사용
{
	return x * x;
}

int main()
{
	std::cout << SQUARE(5) << std::endl;
	std::cout << SQUARE(10) << std::endl;
 
  //std::cout << 5 * 5 << std::endl;         <-- 컴파일시 main()은 다음과 같이 작성된 것처럼 기계 코드를 생성한다.
  //std::cout << 10 * 10 << std::endl;           이로써 더 빠른 실행을 할 수 있다.

	return 0;
}

코드를 부풀릴 가능성이 있으므로 함수를 인라인화 하는 것은 내부 루프가 없는 짧은 함수에 가장 적합하다.
또한 inline 키워드는 권장 사항일 뿐이다. 컴파일러는 인라인에 대한 요청을 자유롭게 무시할 수 있다.
 
컴파일러가 함수의 인라인화가 오히려 성능에 해가 된다고 판단할 경우, 이 키워드를 무시해버린다. 
또한 필요한 경우 일부 함수를 임의로 인라인 처리하기도 한다.
 
     ✅ 인라인 함수를 알고 있어야 하지만 최신 컴파일러는 함수를 적절하게 인라인화 하므로 inline 키워드를 사용할 필요가 없다.
 
------------------------------------------------------------------------------------------ 

인라인 함수는 매크로 함수와 다르게 자료형에 의존하게 되어 데이터를 손실할 수도 있다.
이는 한번만 정의하면 되는 매크로 함수의 장점을 잃게 된 것과 마찬가지다.
 
이를 극복하는 방법으로는 C++의 템플릿이라는 것을 이용하면 된다.
 
#include <iostream>

template <typename T>  // 템플릿 사용

inline T SQUARE(T x)
{
	return x * x;
}

int main()
{
	std::cout << SQUARE(3.14) << std::endl;
	std::cout << SQUARE(10) << std::endl;

	return 0;
}

