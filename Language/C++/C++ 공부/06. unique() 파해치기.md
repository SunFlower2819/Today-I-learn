# `unique()` 함수에 대하여
`unique()` 함수를 사용하면서 중복되는 원소들을 제거하고 뒤에 출력되는 값들의 원리가 궁금했다.   
예를 들어, `{10, 10, 20, 30, 20, 10, 10}`의 배열은 `unique()`를 사용하고 나면은   
`{10, 20, 30, 20, 10, 10, 10}`으로 출력이 된다.

또한 `{ 1, 1, 2, 2, 4, 5, 6 }`의 배열은 `unique()`를 사용하고 나면 `{1, 2, 4, 5, 6, 5, 6}`으로 출력이 된다.

여기서 규칙을 찾아보기가 힘들었다. 하지만 이것 땜에 머리를 아프게하지 않기로 한다.

왜냐하면 중요한 것은  `unique()`함수는 ***연속된 중복 원소를 하나로 합치는 작업을 수행한다는 것이지,***    
배열의 뒷부분에 남아있는 원소들에 어떤 값이 남아 있을지는 중요하지 않기 때문이다.

```cpp
vector<int> v = { 10, 10, 20, 30, 20, 10, 10 };
auto it = unique(v.begin(), v.end());

for (int& i : v)
    cout << i << ' '; // 10, 20, 30, 20, 10, 10, 10 출력 (결론적으로 중요한 것은 10 20 30 20 10 까지이다.)
```
unique의 작동 과정
* {10, 10, 20, 30, 20, 10, 10}이 주어진다.
* 연속된 10은 하나로 압축 → {10, ?, 20, 30, 20, 10, 10}
* 이후 20은 연속되지 않았으므로 그대로 유지
* 30도 중복이 아니므로 유지
* 결과적으로 다른 값들은 그대로 남는다.

결과 벡터
* unique 이후, 벡터는 {10, 20, 30, 20, 10, ?, ?}이 된다.
* 여기서 ?는 unique 이후에 남아 있는 쓰레기 값!

출력
* 전체 벡터를 출력하면 {10, 20, 30, 20, 10, 10, 10}처럼 보인다.
* 하지만 unique가 반환한 위치까지가 우리가 원하는 결과다.


## `erase()`를 사용해보자!
만약 뒷 부분이 너무 거슬린다면, 우리는 `erase()`를 사용하여 아래와 같은 방법을 사용할 수 있다.
```cpp
v.erase(std::unique(v.begin(), v.end()), v.end()); // 10 20 30 20 10

//----- 혹은 ------------------------------

auto it = unique(v.begin(), v.end()); // 첫번째 쓰레기값의 반복자 반환
v.erase(it, v.end()); // 10 20 30 20 10
```
