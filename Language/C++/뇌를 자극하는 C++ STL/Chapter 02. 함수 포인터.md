함수 포인터는 함수의 시작 주소를 저장하는 포인터입니다.

**함수의 이름은 함수가 시작하는 시작 주소이며, 함수 포인터는 이 함수의 주소를 저장하는 포인터입니다.**

🎈🎈 함수 포인터는 함수 시그니처와 같게 선언합니다.
> 함수 시그니처: 함수의 반환 타입과 매개변수 리스트

ex) `int func(int a, int b)` 함수의 함수 포인터는 `int (*pf)(int, int)`와 같이 선언

```cpp
#include <iostream>
using namespace std;

void Print(int n)
{
	cout << "정수: " << n << endl;
}

int main()
{
	// void Print(int n)의 함수 포인터 선언
	void (*pf)(int);
	// 함수의 이름은 함수의 시작 주소
	pf = Print;

	Print(10);   // 1. 함수 호출
	pf(10);      // 2. 포인터를 이용한 함수 호출, 첫 번째 방법
	(*pf)(10);   // 3. 포인터를 이용한 함수 호출, 두 번째 방법

	cout << endl; 
	cout << Print << endl;  // 00007FF66B28155F 출력
	cout << pf << endl;     // 00007FF66B28155F 출력 <-- ✅Q.이해 안되는 부분, 왜 pf와 *pf의 결과 값이 똑같이 나오지..??
	cout << *pf << endl;    // 00007FF66B28155F 출력

	return 0;
}
```

✅A. 우선 `pf()`와 `(*pf)()`는 같은 문장으로 작용한다. 이를 바탕으로 내가 추측을 해봤을 때, <br>
      `pf()`와 `(*pf)()`는 같다는 논리를 충족 시키기 위해서 `pf`와 `*pf`를 같은 값을 가지게 한 것이 아닐까? <br>
      그리고 함수 포인터 `pf`에 값(함수의 주소)을 넣어주지 않으면 런타임 에러가 발생하는 것도 애초에 함수 포인터인 `pf` 자체는 함수의 주소값을 대입해주기 전에는
      컴파일 과정에서 생성이 되지 않기 때문이지 않을까? <br>
      이후에 값을 넣어주었을 때, 함수 포인터 `pf`에 할당된 함수 `Print`와 같은 주소를 공유하기 위함이 아닐까?
