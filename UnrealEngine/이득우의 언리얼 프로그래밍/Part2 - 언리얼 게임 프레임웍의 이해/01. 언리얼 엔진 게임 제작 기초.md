# 강의 목표
* 언리얼 게임 프레임웍을 활용한 게임 제작 방식의 이해
* 강의 예제에 사용되는 프로젝트와 기본 C++ 클래스 생성
* 향후 운영될 C++ 프로젝트 운영 규칙의 이해

---

# 언리얼 게임 프레임웍
* 게임 제작을 위해 언리얼 엔진은 자체적으로 설계한 프레임웍을 제공함.
* 이를 게임플레이 프레임웍(Gameplay Framework)이라고 부름. 줄여서 게임 프레임웍
* 언리얼 게임 프레임웍의 각 구성 요소를 파악하고, 이를 확장하면서 게임을 제작하는 것을 권장

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/ffdcbec8-7c71-4f20-88db-34177921fc23)

<br> 

🎈🎈언리얼 엔진에서 제공하는 게임 샘플 프로젝트는 어떻게 언리얼에서 제공하는 기능을 사용할 수 있는지에 대한 예시가
담겨있는거였구나..

---

이번 강의에서 사용된 게임 플레이 프레임웍의 기능 목록은 아래와 같다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/4c71e090-3f29-490f-b991-1a7d560e65cd)

<br>

## 🔥월드(World)
게임 컨텐츠를 담기 위해 제공되는 가상의 공간을 의미한다.

월드는 시간, 트랜스폼, 틱이라는 독특한 기능을 서비스로 제공한다.

또한 월드 세팅이라는 컨텐츠 제작을 위한 기본 환경 설정을 제공한다.

월드의 기본 단위는 액터(Actor)로 정의되며, 액터 클래스는 언제나 접수사 `A`를 사용한다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/34e6238f-6b70-4196-b6dc-9a4fa6ec4d91)

<br>

## 🔥게임 모드(Game Mode)
게임 모드는 게임의 규칙을 지정하고 게임을 판정하는 최고 관리자 액터이다. 이것은 형태가 없이
논리적인 단위로만 존재를 하는데, 언리얼 엔진에는 하나의 게임에는 반드시 하나의 게임 모드만 존재하도록
설계되었다.

이러한 게임 모드는 입장할 사용자의 규격을 지정할 수가 있고, 
멀티플레이어 게임에서 판정을 처리하는 절대적 권위의 심판 역할을 한다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/06e6938a-61f5-4f8f-8e74-b880b6453710)

<br>

## 🔥기믹(Gimmick)
게임 진행을 위해 이벤트를 발생시켜주는 어떤 사물 엑터를 의미한다. 

기믹은 주로 이벤트 발생을 위한 충돌 영역을 설정하는데, 이를 트리거(Trigger)라고 한다.
이 트리거를 통해서 캐릭터와 상호 작용하고, 월드에 엑터를 스폰해 컨텐츠를 전개한다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/ef415e21-6424-437d-91db-49525d4396b5)


## 🔥플레이어(Player)
게임에 입장한 사용자 엑터이다. 이 또한 형태가 없다.

플레이어는 게임 모드의 로그인 과정을 통해서 사용자가 게임 월드에 입장하면 그 때 생성이 된다.

여기서 로그인이라는 것은 서버 통신을 진행한다는 것이 아니라, 의례적으로 게임 모드가 플레이어를 생성하기 위해
진행되는 절차라고 생각하면 된다.

따라서 싱글 플레이어 게임에서도 로그인을 통해서 사용자가 입장하고 플레이어가 생성이 되는데, 이때는 0번이라는
특수한 아이디가 배정된다.

이러한 플레이어는 사용자와의 일대일로 대응되기 때문에 사용자와의 최종 커뮤니케이션을 담당하게 된다.
예를 들어 입력장치를 해석한다던가, 화면 장치로 출력하는 것을 플레이어가 담당한다고 생각하면 된다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/3d607cf7-95ce-4823-89d5-fe5e04892d1e)

<br>

## 🔥폰(Pawn)
앞서서 플레이어는 무형의 엑터라고 했다. 그렇다면 이는 눈에 보이지 않는다는 것을 의미한다.

언리얼 엔진 같은 경우에는 사용자와 일대일로 대응되는 플레이어는 무형의 엑터이다.
그리고 폰은 이 무형의 엑터인 플레이어가 빙의(Possess)해 조종하는 엑터이다.

폰은 체스에서 졸병 말을 의미하거나, 자신의 의지가 없는 꼭두각시를 의미한다.
이렇게 사전적 의미를 대입해봤을 때, 폰이라고 하는 것은 실제의 의지를 가지고 있지 않고
의지를 가진 플레이어가 빙의해서 조종하는대로 따라주는 사물을 의미한다고 볼 수 있다. 

이러한 폰은 길찾기를 사용할 수가 있으며 기믹 및 다른 폰과 상호작용하도록 설계가 되어 있다. 

폰 중에서 인간형 폰을 별도로 캐릭터(Character)라고 지칭한다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/bc66880d-8e51-41dd-bd99-0aad4ffae535)


---

### 게임의 제작 과정
총 다섯 단계로 나눴다.

이 강의에서는 블루프린트를 사용해 세 단계까지만 작업을 진행했다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/73d0cbab-2e49-4cd3-bcba-07c951997108)


### 최종 예제 컨텐츠의 구성
앞으로 우리가 만들 최종 예제 컨텐츠는 가급적 블루프린트를 사용하지 않고 C++만으로 제작할 예정이다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/d3b9b3c5-14c0-4a84-8934-0c7e283fd2a2)


### 최종 예제에서 확장할 내용
* 기본 템플릿을 사용하지 않고 직접 제작
* 두 가지의 카메라 모드 제공 (숄더뷰, 탑뷰)
* 액션 입력을 통한 콤보 공격의 구현
* 아이템 에셋을 활용한 무기 상자의 구현
* NPC 레벨 정보를 스프레드 시트로 관리
* 플레이어와 전투하는 NPC 인공지능의 구현
* UI 연동과 게임의 마무  

---

# 언리얼 C++ 프로젝트의 생성 

## 🔥프로젝트의 시작
이번 강의에서는 프로젝트를 생성하고 1단계에 해당하는 월드 설정과 게임 모드를 생성해보고 설정하는 작업을 진행하겠다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/ce11d852-344d-4643-9d4f-35cc1ad756b2)


## 🔥프로젝트 소스코드 폴더 규칙

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/95c2f43d-c60b-409d-a193-af47bc2cd606)

## 🔥 클래스 생성 규칙
* 모든 클래스는 AB(ArenaBattle)의 접두사로 시작함
* 폴더마다 다른 폴더와의 의존성을 최소화
* 다른 폴더의 클래스에 접근할 때 가급적 인터페이스를 통해 접근
* 헤더 경로를 찾기 쉽도록 `모듈.Build.cs` 파일에 모듈의 폴더를 인클루드 경로에 설정
  *  `PublicIncludePaths.AddRange(new string[]{"모듈 이름"});` 추가
 
가급적이면 다른 폴더의 헤더를 직접 참조하지 않도록 구성하는 것이 바람직

## 🔥 최초 생성할 클래스
* 게임을 구성하는 기본 골격의 설정
* 캐릭터는 PC와 NPC를 구분해 구현할 예정
* 게임 모드에서는 입장할 플레이어의 규격을 지정 (AABPlayerController, AABCharacterPlayer) 

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/830833e4-2cfe-420f-ae59-c6515c3ab8c3)
























