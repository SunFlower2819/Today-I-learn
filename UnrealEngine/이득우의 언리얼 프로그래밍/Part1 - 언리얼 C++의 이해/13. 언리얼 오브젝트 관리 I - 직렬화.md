# 강의 목표
* 언리얼 엔진이 제공하는 직렬화 기능의 이해
* 언리얼 오브젝트를 직렬화하고 이를 저장하고 불러들이는 방법의 이해

---

# 언리얼 엔진의 직렬화
직렬화(Serialization)란 오브젝트나 오브젝트 끼리 연결된 오브젝트의 묶음(오브젝트 그래프)을 디스크나 네트워크로 전송할 수 있는 
바이트 스트림을 변환하는 과정을 의미한다.

복잡한 오브젝트 정보를 일렬로 구성된 바이트 스트림으로 변환하기 때문에, 즉 모든 데이터를 한 줄로 세웠기 때문에 직렬화라고 한다.

직렬화는 어떤 복잡한 데이터를 한 줄로 변환하는 작업뿐만 아니라, 거꾸로 한 줄로 저장된 데이터를 복잡한 오브젝트로 복구하는
작업까지를 포함한다.

복잡한 오브젝트 그래프에서 한 줄의 바이트 스트림으로 변환하는 것을 시리얼라이제이션(Serialization), 반대로 바이트 스트림에서 복잡한
오브젝트 그래프로 복원하는 것을 디시리얼라이제이션(Deserialization)이라고 한다.

직렬화가 가지고 있는 장점은 아래와 같다.
* 현재 프로그램의 상태를 저장하고 필요할 때 복원할 수 있다. 주로 게임에서 현재의 상태를 저장하는데 사용된다.
* 현재 객체의 정보를 클립보드에 복사해서 다른 프로그램에 전송할 수 있다.
* 네트워크를 통해 현재 프로그램의 상태를 다른 컴푸터에 복원할 수 있다. 멀티플레이어 게임이 예시이다.
* 데이터 압축, 암호화를 통해 데이터를 효율적이고 안전하게 보관할 수 있다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/299d15b4-5b7f-4f68-8add-7418d73a3832)

***🎈🎈이렇게 복잡한 오브젝트들 간에 데이터를 연동할 때 한 줄로된 바이트 스트림으로 변환하는 작업 그리고 복구하는 작업을 Serialization이라고 한다.***

<br>

## 🔥직렬화 구현시 고려할 점
* `데이터 레이아웃` : 오브젝트가 소유한 다양한 데이터를 어떡신으로 변환할 것인가?
  
* `이식성` : 변환된 데이터가 서로 다른 시스템에 전송되어도 똑같이 이식될 수 있는가?  <br>
ex) 리틀 엔디안, 빅 엔디안 처럼 데이터를 저장하는 방법이 서로 다른 경우가 있다.
* `버전 관리` : 새로운 기능이 추가될 때 이를 어떻게 확장하고 처리할 것인가?
* `성능` : 네트웍 비용을 줄이기 위해 어떤 데이터 형식을 사용할 것인가?
* `보안` : 네트워크를 통해서 데이터가 전송될 때는 다른 사람들도 이 데이터를 볼 수 있기 때문에 어떻게 안전하게 데이터를 보호할 것인지 고려해야 한다.
* `에러 처리` : 데이터 전송 과정에서 문제가 발생할 경우 이를 어떻게 인식하고 처리할 것인가?

<br>

## 🔥직렬화 구현시 고려할 점
> 📌Archive 뜻: 기록관, 기록(물)

언리얼 엔진은 이러한 상황을 모두 고려해서 직렬화 시스템을 자체적으로 개발해서 제공하고 있다.

이때 직렬화 시스템을 위해 제공하는 클래스는 `FArchive` 클래스이다.
그리고 `FArchive` 클래스에 우리가 전송할 데이터를 `Shift(<<) operator`를 사용해서 전송해주면,
우리가 원하는 형태로 바이트 스트림을 저장할 수 있게 된다.

`FArchive` 클래스를 상속받는 여러 가지 클래스들을 제공하고 있다.
* 메모리에 전송하는 메모리 아카이브 : `FMemoryReader`, `FMemoryWriter`
  
* 파일에다가 읽고 쓰는 파일 아카이브 : `FArchiveFileReaderGeneric`, `FArchiveFileWriterGeneric`
* 기타 언리얼 오브젝트와 관련된 아카이브 : `FArchiveUObject`

웹 통신에서 많이 사용하는 Json 형태의 직렬화 기능도 제공하는데, 이것들은 별도의 라이브러리에서 제공하고 있다.

---

# 파일 입출력 실습

***꼭 주석을 꼼꼼히 읽어보기!!***

아래의 코드는 C++ 구조체의 정보를 어떻게 파일에 쓰고, 읽어오는지에 대한 코드다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/eb2ee516-4092-4ee9-909a-8ed97b52e8db)


### 💧MyGameInstance.h
```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/GameInstance.h"
#include "MyGameInstance.generated.h"

struct FStudentData
{
	FStudentData() {}
	FStudentData(int32 InOrder, const FString& InName) : Order(InOrder), Name(InName)
	{}

	// &를 안붙혀서 제대로 복사가 안됐다. 이거 땜에 한참 헤맸다.
	// friend 함수를 사용하여 << 연산자를 오버로딩해주어 더 편리하게 설정한다.
	friend FArchive& operator<< (FArchive& Ar, FStudentData& InStudentData)
	{
		Ar << InStudentData.Order;
		Ar << InStudentData.Name;
		return Ar;
	}

	int32 Order = -1;
	FString Name = TEXT("Default Name");
};
/**
 *
 */
UCLASS()
class UNREALSERIALIZATION_API UMyGameInstance : public UGameInstance
{
	GENERATED_BODY()

public:
	UMyGameInstance();

	virtual void Init() override;
};
```

### 💧MyGameInstance.cpp
```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MyGameInstance.h"

UMyGameInstance::UMyGameInstance()
{
}

void UMyGameInstance::Init()
{
	Super::Init();

	// 구조체 객체 RawDataSrc 선언
	FStudentData RawDataSrc(25, TEXT("선태욱"));
	UE_LOG(LogTemp, Log, TEXT("[RawDataSrc] 이름 %s 순번 %d"), *RawDataSrc.Name, RawDataSrc.Order);


	// 👉구조체의 데이터를 파일에 쓰고 읽어와보기

	// 프로젝트 디렉토리 안의 Saved 폴더의 절대 경로를 가져온다.
	const FString SavedDir = FPaths::Combine(FPlatformMisc::ProjectDir(), TEXT("Saved"));
	UE_LOG(LogTemp, Log, TEXT("저장할 파일 폴더: %s"), *SavedDir);

	{
		const FString RawDataFileName(TEXT("RawData.bin"));
		FString RawDataAbsolutePath = FPaths::Combine(*SavedDir, *RawDataFileName);
		UE_LOG(LogTemp, Log, TEXT("저장할 파일 전체 경로: %s"), *RawDataAbsolutePath);
		FPaths::MakeStandardFilename(RawDataAbsolutePath);
		UE_LOG(LogTemp, Log, TEXT("저장할 파일 전체 경로: %s"), *RawDataAbsolutePath);


		// 파일(RawDataAbsolutePath의 경로에 위치한 파일)에 쓸 수 있는 아카이브 클래스를 생성해준다.
		// RawDataAbsolutePath에 저장되어있는 경로, 즉 RawData.bin을 생성하여 쓸 수 있는 아카이브 클래스를 생성할 수 있게 된다.
		// RawFileWriterAr 클래스에 절대 경로를 지정해주고, 구조체 RawDataSrc의 정보를 넣어준다.
		FArchive* RawFileWriterAr = IFileManager::Get().CreateFileWriter(*RawDataAbsolutePath);
		if (RawFileWriterAr != nullptr)
		{
			//*RawFileWriterAr << RawDataSrc.Order;  
			//*RawFileWriterAr << RawDataSrc.Name;
			*RawFileWriterAr << RawDataSrc;  // 🎈🎈 << 연산자를 오버로딩하여 위의 과정을 생략.

			RawFileWriterAr->Close();
			delete RawFileWriterAr;
			RawFileWriterAr = nullptr;
		}


		// 위에서 만든 RawDataSrc의 정보를 읽어들어와서 RawDataDest에다가 덮어쓸 것이다.
		FStudentData RawDataDest;
		FArchive* RawFileReaderAr = IFileManager::Get().CreateFileReader(*RawDataAbsolutePath);
		if (RawFileReaderAr != nullptr)
		{
			// RawFileReaderAr에 쓰여져있는 데이터를 RawDataDest로 옮긴다.
			*RawFileReaderAr << RawDataDest;

			RawFileReaderAr->Close();
			delete RawFileReaderAr;
			RawFileReaderAr = nullptr;

			UE_LOG(LogTemp, Log, TEXT("[RawDataDest] 이름 %s 순번 %d"), *RawDataDest.Name, RawDataDest.Order);
		}
	}
}
```

실행결과는 아래와 같다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/6cefcf6b-20bd-4be7-8262-0d280f43eb47)

 





































