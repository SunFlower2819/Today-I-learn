# 강의 목표
* 언리얼 엔진의 메모리 관리 시스템의 이해
* 안정적으로 언리얼 오브젝트 포인터를 관리하는 방법 학습

---

# 언리얼 엔진의 자동 메모리 관리

## 🔥C++ 언어 메모리 관리의 문제점
C++은 저수준으로 메모리 주소에 직접 접근하는 포인터를 사용해 오브젝트를 관리한다.
그러다보니 프로그래머가 직접 할당(new)과 해지(delete)의 짝 맞추기를 해야 한다.

이를 잘 지키지 못하는 경우엔 다양한 문제가 발생할 수 있다.

* 메모리 누수(Leak): new를 했는데 delete 짝을 맞추지 못할 경우. 힙에 메모리가 그대로 남아있음.
* 허상(Dangling) 포인터: (다른 곳에서) 이미 해제해 무효화된 오브젝트의 주소를 가리키는 포인터
* 와일드(Wild) 포인터: 값이 초기화되지 않아 엉뚱한 주소를 가리키는 포인터

이렇게 잘못된 포인터 값은 다양한 문제를 일으키며, 한번의 실수로 프로그램을 종료시켜버리기도 한다.
게임의 규모가 커지고 구조가 복잡해질수록 프로그래머가 실수할 확률은 크게 증가한다.

***C++ 이후에 나온 Java/C#은 이러한 고질적인 문제를 해결하기 위해 포인터를 버리고
대신 가비지 컬렉션 시스템을 도입했다.***  

## 🔥가바지 컬렉션 시스템
프로그램에서 더 이상 사용하지 않는 오브젝트를 자동으로 감지해 메모리를 회수하는 시스템이다.

동적으로 생성된 모든 오브젝트 정보를 모아둔 저장소를 사용해 사용되지 않는 메모리를 추적한다.           

**마크-스윕(Mark-Sweep)** 방식의 가비지 컬렉션
1. 저장소에서 최초 검색을 시작하는 루트 오브젝트를 표기한다.
2. 루트 오브젝트가 참조하는 객체를 찾아 ***마크(Mark)*** 한다.
3. 마크된 객체로부터 다시 참조하는 객체를 찾아 마크하고 이를 계속 반복한다.
4. 이제 저장소에는 마크된 객체와 마크되지 않은 객체의 두 그룹으로 나뉜다.
5. 가비지 컬렉터가 저장소에서 마크되지 않은 객체(가비지)들의 메모리를 회수한다.(Sweep) 

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/5b6adc77-4fd3-4b83-9b0e-dc9b74d845a3)

<br>


## 🔥언리얼 엔진의 가비지 컬렉션 시스템
* 마크-스윕 방식의 가비지 컬렉션 시스템을 자체적으로 구축함.
* 지정된 주기마다 몰아서 없애도록 설정되어 있음. (GCCycle. 기본 값은 60초)

이러한 가비지 컬렉터가 백그라운더에서 진행하는 작업이 부화가 적지는 않다.
따라서 언리얼 엔진은 퍼포먼스를 높이기 위해서 병렬 처리, 클러스터링과 같은 기능을 탑재했다.

<br>

## 🔥가비지 컬렉션을 위한 객체 저장소
언리얼 엔진에서는 관리되는 모든 언리얼 오브젝트의 정보를 저장하는 전역 변수가 있다.

전역(Global)을 의미하는 G로 시작하는데 `GUObjectArray`라고한다. 

따라서 언리얼 엔진이 활성화된 시간에 누구나 `GUObjectArray`에 접근할 수가 있는데, 이 `GUObjectArray`에 각 요소에는
플레그(Flag)라는 정보가 설정 되어 있다.

여기에는 다양한 값을 설정할 수 있는데 가바지 컬렉터가 참고하는 주요 플래그 두 가지는 아래와 같다.
* Garbage 플래그: 다른 언리얼 오브젝트로부터의 참조가 없어 회수 예정인 오브젝트
* RootSet 플래그: 다른 언리얼 오브젝트로부터 참조가 없어도 회수하지 않는 특별한 오브젝트

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/5c8a050b-b758-4bde-bffe-cebbb56d5edc)

<br>

## 🔥가비지 컬렉션의 메모리 회수
* 가비지 컬렉터는 지정된 시간에 따라 주기적으로 메모리를 회수한다. (기본 값 60초)
* Garbage 플래그로 설정된 오브젝트를 파악하고 메모리를 안전하게 회수함.
* Garbage 플래그는 `GUObjectArray`에 접근해서 수동으로 설정하는 것이 아닌, 시스템이 알아서 설정함.

***🎈🎈한번 생성된 오브젝트를 삭제하기 위해서는 C++의 `delete`키워드를 사용해서 바로 삭제하는 것이 아닌,
레퍼런스 정보를 없앰으로써 언리얼의 가비지 컬렉터가 자동으로 메모리를 회수하도록 설정하는 것이다.***

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/f91283f8-5807-455b-9d08-39535f546cc6)

<br>

## 🔥루트셋 플래그의 설정
만약에 내가 어떤 언리얼 오브젝트를 만들었는데, 시스템이 실행되는 동안에 계속해서 이 오브젝트가 살아있어야 한다면, 
이러한 경우에는 루트셋(RootSet)으로 등록해 주면 된다.

`GUObjectArray`에서 제공하는 `AddtoRoot()` 함수를 호출하면 자동으로 해당 오브젝트가 루트셋(RootSet)으로 설정돼서
메모리의 회수로부터 보호를 받게 된다.

만약 그 오브젝트가 더 이상 필요 없으면 `GUObjectArray`에서 제공하는 `RemoveFromRoot()`함수를 호출해 루트셋 플래그를 제거할 수 있다.

하지만 이러한 방법은 컨텐츠를 만들 때 권장이 되지는 않는다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/63ae6e70-b76d-4388-ae2f-1889fec3a7c5)

<br>

## 🔥언리얼 오브젝트를 통한 포인터 문제의 해결
이러한 언리얼 엔진의 가비지 컬렉션 시스템을 사용하면 얻을 수 있는 이점은 아래와 같다.

1. 메모리 누수 문제 해결
   * 언리얼 오브젝트는 가비지 컬렉터를 통해 자동으로 해결.
   * 만약 언리얼 오브젝트가 아닌, C++ 오브젝트를 사용한다면 이는 직접 신경써야 한다. (스마트 포인터 라이브러리 활용)

2. 댕글링 포인터 문제 해결
   * 언리얼 오브젝트는 이를 탐지하기 위한 함수렐 제공함 -> `IsValid()`
   * 당연히 C++ 오브젝트는 직접 신경을 써야 함. (스마트 포인터 라이브러리 활용)

3. 와일드 포인터 문제 해결
   * 언리얼 오브젝트에 `UPROPERTY`속성을 지정하면 자동으로 `nullptr`로 초기화 해준다.
   * 하지만 C++ 오브젝트의 포인터는 직접 `nullptr`로 초기화 해야 한다. (또는 스마트 포인터 라이브러리 활용)

<br>

## 🔥회수되지 않는 언리얼 오브젝트
* 언리얼 엔진 방식으로 참조를 설정한 언리얼 오브젝트
  * `UPROPERTY`로 참조된 언리얼 오브젝트 (대부분의 경우 이를사용)
  * `AddReferencedObject` 함수를 통해 참조를 설정한 언리얼 오브젝트
    
* 루트셋(RootSet)으로 지정된 언리얼 오브젝트 -> 사실상 그 오브젝트가 중요하다는 것을 의미하므로 많이 사용되지는 않는다.

  
***🎈🎈클래스 내에서 오브젝트 포인터를 멤버로 선언할 때 가급적 `UPROPERTY`로 선언하고, 메모리는 가비지 컬렉터가 자동으로 관리하도록 위임한다.*** 

<br>

## 🔥일반 클래스에서 언리얼 오브젝트를 관리하는 경우
`UPROPERTY`를 사용하지 못하는 환경에서 언리얼 오브젝트를 관리해야 하는 드문 경우가 있다.

어떠한 C++ 객체에 언리얼 오브젝트가 멤버 변수로 들어가는 경우인 형태이다.

이때는 `FGC`라는 오브젝트틑 상속받은 다음에 `AddReferencedObject`라는 함수를 구현해주면 된다.

이 부분은 컨텐츠 제작에서 자주 사용하는 방법은 아니다.

* `UPROPERTY`를 사용하지 못하는 일반 C++ 클래스가 언리얼 오브젝트를 관리해야 하는 경우
* `FGCObject` 클래스를 상속받은 후 `AddReferencedObjects` 함수를 구현한다.
* 함수 구현 부에서 관리할 언리얼 오브젝트를 추가해 줌. 

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/e7eacdbb-6288-4ce7-9645-9fc2a8296144)

<br>

## 🔥언리얼 오브젝트의 관리 원칙
* 생성된 언리얼 오브젝트를 유지하기 위해 레퍼런스 참조 방법을 설계할 것
  * 언리얼 오브젝트 내의 언리얼 오브젝트 : `UPROPERTY` 사용
  * 일반 C++ 오브젝트 내의 언리얼 오브젝트 : `FGCObject` 상속 후 구현

* 생성된 언리얼 오브젝트는 강제로 지우려 하지 말 것
  * 참조를 끊는다는 생각으로 설계할 것
  * 가비지 컬렉터에게 회수를 재촉할 수는 있음 (`ForceGarbageCollection` 함수)
  * 콘텐츠 제작에서 `Destroy`함수를 사용할 수 있으나, 결국 내부 동작은 동일함. (가비지 컬렉터에 위임) 








































