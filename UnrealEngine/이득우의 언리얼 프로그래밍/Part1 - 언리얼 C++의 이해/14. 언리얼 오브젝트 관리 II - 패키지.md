# 강의 목표
* 언리얼 엔진의 에셋과 이를 포장한 패키지의 개념 이해
* 언리얼 에디터에서 볼 수 있도록 애셋을 저장하고 불러들이는 방법의 이해
* 오브젝트 패스를 사용해 다양한 방식으로 에셋을 로딩하는 방법의 이해

---

# 언리얼 오브젝트 패키지
단일 언리얼 오브젝트가 가진 정보는 저장할 수 있지만, 오브젝트들이 조합되어 있다면? 저장된 언리얼 오브젝트 데이터를 효과적으로 찾고 관리하는 방법은 무엇일까?

=> 복잡한 계층 구조를 가진 언리얼 오브젝트를 효과적으로 저장과 불러들이는 방법을 하나로 통일해야 한다.
    
언리얼 엔진은 이를 위해 패키지(UPackage) 단위로 언리얼 오브젝트를 관리함.
  
패키지라는 용어는 중의적 개념이 존재한다.
언리얼 엔진은 다양한 곳에서 패키지를 사용하고 있으므로, 혼돈에 주의해야 한다.

* 이번 강의에서의 패키지는 언리얼 오브젝트를 감싼 포장 오브젝트를 의미한다.
* 또한 게임 패키징같이 개발된 최종 컨텐츠를 정리해 프로그램으로 만드는 작업을 의미하기도 한다.
* 또한 pkg파일과 같이 DLC와 같이 향후 확장 컨텐츠에 사용되는 별도의 데이터 묶음을 의미하기도 한다.

이처럼 구분을 위해 ***언리얼 오브젝트 패키지***로 부르는 것도 고려

<br>

## 🔥패키지(Package)와 에셋(Asset)
언리얼 오브젝트 패키지는 다수의 언리얼 오브젝트를 포장하는데 사용하는 언리얼 오브젝트를 의미한다.
사실 우리가 생성한 모든 언리얼 오브젝트는 패키지에 소속되어 있다. 이름은 `Transient Package`로 임시 패키지이다.

이러한 언리얼 오브젝트 패키지가 소유한 다양한 언리얼 오브젝트 중에서 바로 하단에 위치한 
서브 오브젝트를 에셋이라고 한다. 에디터에는 패키지 정보가 노출되는 것이 아니라 이 에셋 정보가 노출된다.

그래서 구조상 패키지는 여러 개의 에셋들을 소유할 수가 있는데, 일반적으로는 하나의 패키지에 하나의 에셋만 가지도록
설계한다.

이러한 에셋들은 다수의 서브 오브젝트를 가질 수 있는데, 이것들은 모두 언리얼 오브젝트 패키지에 포함돼서
저장된다.

하지만 서브 오브젝트들은 에디터에 노출되지 않는다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/bbb2e9bf-2d6e-41fd-8a0f-941013dcc2b6)

<br>

이번에는 직렬화 클래스를 사용해서 수동으로 언리얼 오브젝트 정보를 저장하는 것이 아니고 패키지를 사용해서
언리얼 에디터에서 볼 수 있는 에셋을 저장해보겠다.
 

## 🔥언리얼 오브젝트 패키지를 사용해서 에셋을 저장하고 불러오기
### 💧MyGameInstance.h
```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/GameInstance.h"
#include "MyGameInstance.generated.h"

struct FStudentData
{
	FStudentData() {}
	FStudentData(int32 InOrder, const FString& InName) : Order(InOrder), Name(InName)
	{}

	friend FArchive& operator<< (FArchive& Ar, FStudentData& InStudentData)
	{
		Ar << InStudentData.Order;
		Ar << InStudentData.Name;
		return Ar;
	}

	int32 Order = -1;
	FString Name = TEXT("Default Name");
};
/**
 * 
 */
UCLASS()
class UNREALSERIALIZATION_API UMyGameInstance : public UGameInstance
{
	GENERATED_BODY()
	
public:
	UMyGameInstance();

	virtual void Init() override;

	void SaveStudentPackage() const;  // 🎈🎈 패키지 저장 함수
	void LoadStudentPackage() const;  // 🎈🎈 패키지 불러오는 함수

private:
	static const FString PackageName;
	static const FString AssetName;

	UPROPERTY()
	TObjectPtr<class UStudent> StudentSrc;
};
```

### 💧MyGameInstance.cpp
```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "MyGameInstance.h"
#include "Student.h"
#include "JsonObjectConverter.h" 
#include "UObject/SavePackage.h" 

// 언리얼 엔진 프로젝트를 기동하게 되면 각각에 대해서는 고유한 경로를 가지게 된다.
// 그 고유한 경로중 하나가 /Game인데 이것은 게임에서 사용되는 에셋들을 모아놓은 대표 폴더를 의미한다.
// 참고로 직렬화 실습에서 사용한 폴더인 Saved 폴더 같은 경우에는 /Temp라는 폴더에 매핑되어 있다.
const FString UMyGameInstance::PackageName = TEXT("/Game/Student"); // 패키지 이름 설정
const FString UMyGameInstance::AssetName = TEXT("Student");  // 에셋 이름 설정

// Student 오브젝트 정보를 출력하는 함수
void PrintStudentInfo(const UStudent* InStudent, const FString& InTag)
{
	UE_LOG(LogTemp, Log, TEXT("[%s] 이름 %s 순번 %d"), *InTag, *InStudent->GetName(), InStudent->GetOrder());
}

UMyGameInstance::UMyGameInstance()
{
}

void UMyGameInstance::Init()
{
	Super::Init();

	FStudentData RawDataSrc(25, TEXT("선태욱"));

	SaveStudentPackage();
	LoadStudentPackage();
}

// 패키지를 저장하기
void UMyGameInstance::SaveStudentPackage() const
{
	// 패지키를 저장할 때 이미 패지키가 있다면 이것을 다 로딩하고 저장해주는 것이 좋다.
	UPackage* StudentPackage = ::LoadPackage(nullptr, *PackageName, LOAD_None);
	if (StudentPackage)
	{
		StudentPackage->FullyLoad();
	}

	StudentPackage = CreatePackage(*PackageName);
	EObjectFlags ObjectFlag = RF_Public | RF_Standalone;


	/*
		UStudent* TopStudent = NewObject<UStudent>();

		위의 코드 처럼 인자가 아무것도 안들어가는 경우에는 Transient Package라는 임시 패키지 안에 언리얼 오브젝트가 저장이 된다.
		그런데 우리는 TopStudent 객체를 Student 패키지 안에다가 넣어줘어야 하기 때문에

		아래 코드와 같이 인자에 클래스 정보, 패키지 정보 등을 넣어준다.
	*/
	UStudent* TopStudent = NewObject<UStudent>(StudentPackage, UStudent::StaticClass(), *AssetName, ObjectFlag);
	TopStudent->SetName(TEXT("선태욱"));
	TopStudent->SetOrder(100);

	const int32 NumOfSubs = 10;
	for(int32 ix = 1; ix <= NumOfSubs; ix++)
	{
		// TopStudent의 서브 오브젝트인 SubStudent 생성
		FString SubObjectName = FString::Printf(TEXT("Student%d"), ix);
		UStudent* SubStudent = NewObject<UStudent>(TopStudent, UStudent::StaticClass(), *SubObjectName, ObjectFlag);
		SubStudent->SetName(FString::Printf(TEXT("학생%d"), ix));
		SubStudent->SetOrder(ix);
	}

	const FString PackageFileName = FPackageName::LongPackageNameToFilename(PackageName, FPackageName::GetAssetPackageExtension());
	FSavePackageArgs SaveArgs;
	SaveArgs.TopLevelFlags = ObjectFlag;

	if (UPackage::SavePackage(StudentPackage, nullptr, *PackageFileName, SaveArgs))
	{
		UE_LOG(LogTemp, Log, TEXT("패키지가 성공적으로 저장되었습니다."));
	}
}

// 패키지를 불러오기
void UMyGameInstance::LoadStudentPackage() const
{
	UPackage* StudentPackage = ::LoadPackage(nullptr, *PackageName, LOAD_None);

	if (nullptr == StudentPackage)
	{
		UE_LOG(LogTemp, Warning, TEXT("패키지를 찾을 수 없습니다!"));
		return;
	}

	StudentPackage->FullyLoad();

	// StudentPackage 안에서 *AssetName, 즉 TopStudent이라는 이름을 가지고 
	// UStudent 타입의 언리얼 오브젝트 에셋을 찾아서 반환시킨다.
	UStudent* TopStudent = FindObject<UStudent>(StudentPackage, *AssetName);
	PrintStudentInfo(TopStudent, TEXT("FindObject Asset"));
}
```
실행결과는 아래와 같다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/cddf672e-f414-487e-aa27-9d446f4c7226)


아래와 같이 에셋이 Student 에셋이 생성되는데, 왜 Student파일 안에 생성이 되지 않는지 잘 모르겠다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/e0f46e93-063f-433b-aa41-e4e91b2afc1f)

---

# 에셋 참조와 로딩









































