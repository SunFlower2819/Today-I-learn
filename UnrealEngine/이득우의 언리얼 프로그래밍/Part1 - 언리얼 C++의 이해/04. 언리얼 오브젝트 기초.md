# 강의 목표 
* 게임 프로그래밍이 가지는 특수성과 언리얼 오브젝트의 필요성의 이해
* 언리얼 오브젝트의 선언과 엔젠 내부 컴파일 과정의 학습

# Unreal Object 소개
> **📌언리얼 오브젝트 공식 문서** <br>
> https://dev.epicgames.com/documentation/ko-kr/unreal-engine/objects-in-unreal-engine?application_version=5.1
## 🔥게임 프로그래밍의 특수성
게임 프로그래밍은 사용자 관점에서는 쾌적한 관점을 위해서 단일 컴퓨터에서 최대 성능을 뽑아내야 한다.

하지만 개발자 관점에서는, 게임의 규모가 커질 수록, 방대하고 복잡한 기능을 안정적으로 관리할 수 있어야 한다.
즉, 성능과 안정성을 둘 다 잡아야 하지만, 하나만 선택을 하고자 했을 땐 사용자를 위한 성능을 선택해야 한다.

이를 위해 게임은 대부분 하드웨어에 직접 접근하여 성능을 높힐 수 있는 C++를 사용하여 개발된다.
C++는 안정성보다 성능을 중시하도록 설계가 되어 있어서, 메모리를 직접 제어하고 Cache 활용을 극대화 시킬 수 있다.
또한 저수준에서 하드웨어 및 운영체제에 직접 접근이 가능하여 높은 성능을 발휘하고, 자료구조를 다룰 때도 복사 작업을 최소화하기에
보다 성능을 향상 시킬 수 있다.

하지만 C++ 언어 이후의 언어인 자바나 C#같은 경우에는 성능보다 안정성을 중시하도록 설계가 되어 있다.
이러한 언어들은 유지보수성이 뛰어나고 자동으로 메모리를 관리해 프로그래머들의 실수로부터 안전하게 프로그램을 지켜준다는 특징이 있다.

* 사용자: 쾌적한 경험을 위해 단일 컴퓨터에서 최대 성능을 뽑아 내야 한다.
* 개발자: 게임의 규모가 커질수록 방대하고 복잡한 기능을 안정적으로 관리해야 한다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/52281dcf-c234-4921-9c97-e09a90bc0d43)

## 🔥C++언어의 단점
* 1970년대에 개발된 C++ 언어
  * 객체지향 프로그래밍의 선두 주자
  * 지속적으로 개선해왔지만, 익혀야 할 내용이 많이 초급자가 학습하기 어려움
  * 하드웨어에 직접 접근하기 때문에, 잘못 사용하면 프로그램에 큰 영향을 미침
* 1990년 중반 이후 C++의 단점을 보완한 후발 언어의등장 (Java, C#)
  * C++의 불필요한 기능을 걷어내고, 최대한 명확하고, 간결하게 설계
  * 성능보다 안정성과 생산성을 중요시
  * 하드웨어에 직접 접근하지 않고, 가상 머신을 통해 간접적으로 접근


## 🔥모던 객체 지향 설계 원칙
* 디자인 패턴을 필두로안정적인 설계 방법이 연구됨.
* 현재 시점에서 모든(Modern)하다는 뜻은 아님.
  
* 유지보수와 유연함, 확장성 향상을 위한 객체 지향 프로그래밍 원칙 (SOLID)
  * ***Single responsibility principle: 하나의 클래스는 하나의 책임만 가져야 한다.***
  * ***Open/closed principle: 클래스 설계를 변경하지 않고 동작을 확장할 수 있어야 한다.***
  * ***Liskov substitution principle: 자식 클래스는 부모 클래스를 대체 사용할 수 있어야 한다.***
  * ***Interface segregation principle: 작고 명확한 인터페이스들로 분리해 관리해야 한다.***
  * ***Dependency inversion principle: 구현을 배제시킨 상위 정책을 바라보며 설계해야 한다.***
    
* 후발 언어(C#, Java)등이 보완한 새로운기능
  * 인터페이스(Interface): 객체 설계의 틀을 제공하는 추상 클래스
  * 리플렉션(Reflection): 런타임에서 객체의 구조를 파악하고 객체에 메타데이터를 부여
  * 델리게이트(Delegate): 프로그램에서 발생한 이벤트를 다수의 객체에 효과적으로 전달하는데 활용
 

***게임 규모가 대형화되면서 모던 객체 지향 설계 도입이 필요해짐***

## 🔥언리얼 엔진의 선택
모던 객체 지향 설계를 위해 언리얼 엔진이 선택한 방법은 C++의 확장이다.
아무래도 성능을 위해서 C++를 버릴 수는 없기 때문에, C++ 언어의 매크로 기능을 활용해서
모던 객체 지향 언어들이 가지고 있는 기능들을 언리얼 엔진이 자체적으로 구현해버렸다.

그래서 언리얼 C++이라는 새로운 시스템은 성능과 안정성을 둘다 잡을 수 있게 된다.

* 성능을 위해 기존 C++ 언어를 포기할 수 없음.
* 기존 C++언어를 확장해 모던 객체 지향 설계를 가능하도록 만듬.
* 모던 객체 지향 설계를 위한 새로운 시스템 구축

## 🔥언리얼 오브젝트
언리얼 C++의 핵심은 언리얼 오브젝트라 불리는 독특한 객체 시스템이 있다.

언리얼 엔진은 C++를 토대로 제작되었기 때문에 일반 C++ 언어에서 사용했던 그 객체 시스템은 그대로 사용할 수 있지만,
언리얼 오브젝트라고 하는 새로운 언리얼만의 객체 규약을 사용해서 객체를 설계할 수 있다.

언리얼 오브젝트를 사용하면 Java나 C#등이 가진 장점을 사용해서 생산성을 높일 수가 있다. 

***이 둘을 구분하기 위해서 일반 C++ 오브젝트는 `F`, 언리얼 오브젝트는 접두사 `U`를 사용한다.***

🎈🎈일반 C++ 오브젝트는 주로 저수준의 빠른 처리를 위한 기능 구현에 사용이 되고, 언리얼 오브젝트는 컨텐츠 제작과 관련된
복잡한 설계 구현에 주로 사용된다. 

<br>

* 언리얼 엔진이 설계한새로운 시스템의 단위 오브젝트(객체)
  * 기존 C++ 오브젝트에 모던 객체 지향 설계를 위한 다양한 기능을 추가한 오브젝트
  * 일반 C++ 오브젝트와 언리얼 오브젝트의 두 객체를 모두 사용할 수 있음.
  * 구분을 위해 일반 C++ 오브젝트는 F, 언일얼 오브젝트는 접두사 U를 사용함.
  
* 각 오브젝트의 사용 용도
  * C++ 오브젝트: 저수준의 빠른 처리를 위한 기능 구현에 사용.
  * 언리얼 오브젝트: 콘텐츠 제작에 관련된 복잡한 설계 구현에 사용.   

## 🔥언리얼 오브젝트가 가지는 특징
* 클래스 기본 객체(CDO): 클래스의 기본 값과 타입 정보의 제공
* 리플렉션(Reflection): 런타임에서 클래스 정보의 참조 기능
* 인터페이스(Interface): 모던 객체 지향 언어가 제공하는 인터페이스의 제공
* 향상된 열거형: 보다 향상된 열거형의 지원
* 델리게이트(Deligate): 객체간의 결합을 낮출 수 있는 델리게이트 기능의 제공
* 가비지컬렉션(Garbage Collection): 자동 메모리 관리
* 향상된 구조체(Struct): 리플렉션이 가능한 구조체의 지원
* 직렬화(Serialization): 객체 정보를 바이트 스트림으로 저장, 전송, 불러들이는 기능

앞으로 공부할 내용들..  

# 언리얼 오브젝트의 선언

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/7ced8f1c-a982-4d6b-8c60-0690b1fdbab9)
 
![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/bb83998b-2d1f-46bc-b317-11711eb09e01)

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "MyObject.generated.h"

/**
 * 
 */
UCLASS() // 언리얼 오브젝트 선언임을 명시하는 UCLASS 매크로 
class UNREALOBJECT_API UMyObject : public UObject // 접두사 U가 붙은 UMyObject 클래스
{
	GENERATED_BODY()
	/*
	GENERATED_BODY()는 generated.h을 사용한다는 것이다. 매우 복잡하게 이루어져 있다. 
	이와 관련된 내용들은 객체 지향 설계을 위해 제공되는
	좋은 기능들을 언리얼 엔진이 자동으로 지원해준다는 의미를 가진다.
	매우 꽁꽁 숨겨져 있어서 완전히 이해보다는 이러한 구조를 가진다 정도로 알면 된다.
	*/
};
```

> **📌언리얼 오브젝트의 선언 규칙**
> 1. 클래스이름.generated.h를 반드시 가장 마지막에 include 시켜주어야 합니다.
> 2. 클래스 선언 전에 UCLASS매크로를 사용해야 합니다.
> 3. 언리얼 오브젝트의 접두사는 U, A 그리고 S가 있습니다. 액터 기반이라면 A를 액터 기반이 아니라면 모두 U를 써주되 UI를 담당하는 슬레이트만 S를 사용하면 됩니다.
> 4. UObject 클래스는 언리얼 오브젝트 최상단에 위치한 기본 클래스입니다. 이로 상속받은 클래스는 모두 언리얼 오브젝트가 됩니다.
> 5. 클래스 선언 내부에 GENERATED_BODY() 매크로도 선언해줍니다. <br>
>
> [출처] [1-4] 언리얼 오브젝트|작성자 이득우



언리얼 오브젝트에 코드를 분석하는 단계가 한 단계로 바로 컴파일 되는 것이 아니고,
UnrealHeaderTool에 의해서 소스 코드를 자동으로 생성하고, 자동으로 생성된 코드를 포함해서
마지막 최종 Build를 진행하는 두 단계의 과정으로 진행된다고 이해하면 된다. 

언리얼 엔진은 자동으로 관련된 코드를 생성하도록 UnrealHeaderTool라는 도구를 제공한다.
UnrealHeaderTool은 자동으로 추가 코드를 만들어내서, 언리얼 오브젝트에서 다양한 기능이 지원되도록 도와주는 역할을 한다.

개발자는 단순히 지정된 매크로만 입력해주면 되고, UnrealHeaderTool이 자동으로 생성되는 헤더 파일에는 접근할 필요가 없다.

이러한 언리얼 오브젝트는 대규모 게임 프로젝트을 안정적으로 설계하고 구현하는데 큰 도움을 주기때문에 언리얼 엔진의
핵심 기술이라고 할 수 있다.
