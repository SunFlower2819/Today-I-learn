# 강의 목표
* 느슨한 결합의 장점과 이를 편리하게 구현하도록 도와주는 델리게이트의 이해
* 발행 구독 디자인 패턴의 이해
* 언리얼 델리게이트를 활용한 느슨한 결합의 설계와 구현의 학습

# 느슨한 결합(Loos Coupling)

객체 지향 설계에서 강한 결합과 느슨한 결합이라는 단어가 있다.

강한 결합은 클래스들이 서로 의존성을 가지는 경우를 의미하는데, 앞 강의에서 `Person` 클래스는 직접 맴버 변수로
`Card`클래스를 사용하고 있다. 이렇게 되는 경우에 `Person`은 카드에 대해서 의존한다고 표현한다.

만약에 학교에서 카드가 아닌 핸드폰으로 출입을 인증하는 시스템이 도입 되었다고 한다면, `Person`과 이를 상속받은 자식 클래스들은
어떻게 대처 해야할까?

만약 `Person`에 휴대폰 인증과 관련된 새로운 
멤버 변수를 추가하거나 `Card` 클래스를 수정하게 되면, 
`Student`, `Teacher`, `Staff`와 같은 기존의 자식 클래스들의 코드 또한 같이 수정해줘야만 한다.

이러한 문제를 해결하기 위한 결합 법칙이 ***느슨한 결합***이다.

앞서서, 클래스를 설계할 때 실물에 의존하지말고 추상적 설계에 의존하라고 헀다. 
즉, `Card`가 아니라, `Card`를 통해서 무엇을 할지에 대해 생각해보자는 것이다.

왜 `Person`은 카드가 필요할까? 바로 출입을 위함이다.
그렇다면, 출입에 관련된 추상적인 설계를 구현하고 카드가 이것을 구현하도록 구조를 만드는 것이 좋다. 

이로 인해, Person은 `Card`에 의존하지 않고 출입에 관련된 클래스인 `ICheck`에 의존하게 된다.
앞으로 출입증이 핸드폰으로 바뀌더라도 핸드폰이 `ICheck`를 구현할 수 있다면, `Person`의 코드를 바꾸지 않아도
출입 체크 수단을 변경하는 것이 가능하다.

이것이 앞서 살펴본 인터페이스가 가지는 장점이다.

<br>

* 강한 결합(Tight Coupling)
  * 클래스들이 서로 의존성을 가지는 경우를 의미한다.
  * 아래 예시에서 Card가 없는 경우 Person이 만들어질 수 없다.
  * 이 때 Person은 Card에 대한 의존성을 가진다고 한다.
  * 핸드폰에서도 인증할 수 있는 새로운 카드가 도입된다면?
 
* 느슨한 결합(Loose Coupling)
  * 실물에 의존하지 말고 추상적 설계에 의존하라. (DIP 원칙)
  * 왜 Person은 Card가 필요한가? 출입을 확인해야 하기 때문
  * 출입에 관련된 추상적인 설계에 의존하다.
  * ICheck를 상속받은 새로운 카드 인터페이스를 선언해 해결
  * 이러한 느슨한 결합 구조는 유지 보수를 손쉽게 만들어줌
 
```cpp
class Card
{
public:
	Card(int InId) : Id(InId) {}
	int Id = 0;
};

class Person  // Person 클래스 안에 Card 멤버 변수가 선언되어 있다. (강한 결합)
{
public:
	Person(Card InCard) : IdCard(InCard) {}

protected:
	Card IdCard;
};
```

```cpp
class ICheck // 출입과 관련된 추상 클래스 (느슨한 결합)
{
public:
	virtual bool check() = 0; // 순수 가상 함수
};

class Card : public ICheck
{
public:
	Card(int InId) : Id(InId) {} 

	virtual bool check() override { return true; }

private:
	int Id = 0;
};

class Person
{
public:
	Person(ICheck* InCheck) : Check(InCheck) {}

protected:
	ICheck* Check;
};
```

그런데 이렇게 행동의 중심을 둔 추상화 작업을 통해서 매번 인터페이스를 만드는 것이 번거로울 수 있다.
그렇다면 어떤 행동에 대해서, 즉 어떤 함수를 오브젝트 처럼 관리하면 어떨까 생각할 수 있다.

## 🔥느슨한 결합의 간편한 구현 - 델리게이트(Delegate)
* 그렇다면 함수를 오브젝트처럼 관리하면 어떨까?
* 함수를 다루는 방법
  * 함수 포인터를 활용한 콜백(Callback) 함수의 구현
  * 가능은 하나 이를 정의하고 사용하는 과정이 꽤나 복잡함
  * 안정성을 스스로 검증해주어야 함
  * C++ 17의 규약의 std::bind와 std::function 활용은 느림

* C#의 델리게이트(delegate) 키워드
  * 함수를 마치 객체처럼 다룰 수 있음
  * 안정적이고 간편한 선언
 
* 언리얼 C++도 델리게이트를 지원함
  * 느슨한 결합 구조를 간편하고 안정적으로 구현할 수 있음

<br>

> 📌**언리얼 델리게이트 공식문서** <br>
> https://dev.epicgames.com/documentation/ko-kr/unreal-engine/delegates-and-lamba-functions-in-unreal-engine?application_version=5.1

