***많이 헤맨 문제이다. 모든지 하나의 생각에 몰두하면 다른 생각을 차단시켜, 스스로의 시야를 가로막는다는 것을 가끔 코딩을 할 때 다시금 깨닫는다.
역시 항상 내가 너무 편협한 사고를 하고 있지 않은가, 스스로 매번 점검하는 자세가 필요함을 또 다시 느낀다.***

<br>

사실 문제 자체는 어렵지 않은 문제이다.
조건은 다음과 같다.
1. 첫째 줄 단어 S입력. (100문자 이하, 소문자로만 구성)
2. 문자열의 각 문자의 순번을 a~z 순으로 나열, 단 단어에 없는 문자는 -1로 출력

```
예시 
입력: baekjoon
출력: 1 0 -1 -1 2 -1 -1 -1 -1 4 3 -1 -1 7 5 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
```

사실 이 문제에서 가장 중요한 포인트는 이와 같다.   
***문자열의 각 문자의 인덱스가 곧 그 문자가 등장한 순서를 가리키는 번호이다.***

나는 이 포인트를 잡지 못했다. 그래서 돌고 돌았다. 머리도 돌아버렸다.

코딩을 한 결과는 다음과 같다.
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

int main()
{
    char str[100];
    cin >> str;

    vector<int> v(26, -1); // 알파벳 26개에 대해 초기값 -1로 설정

    for (int i = 0; i < strlen(str); i++)
    {
        int index = str[i] - 'a'; // 현재 문자의 알파벳 인덱스 계산
        if (v[index] == -1)     // 해당 알파벳이 처음 등장한 경우만 처리
        {
            v[index] = i;       // 등장한 위치(인덱스) 저장
        }
    }

    // 결과 출력
    for (int& i : v)
    {
        cout << i << " ";
    }

    return 0;
}
```

하지만 모든 것이 완벽하다고 생각한 위의 코드는 '틀렸습니다'를 출력했다.   
도대체 무엇이 문제였을까?   

바로 `\0`, 즉 **널문자**를 생각하지 않아서 틀렸던 것이었다.   
널문자는 C,C++에서 `char`문자열의 끝을 알려주는 특수한 문자이다.   

즉 문자열을 담는 변수인 `char str[100]`의 크기를 `char str[101]`로 수정을 해줘야 한다.

```cpp
char str[101]; // 문자열 크기를 수정 
```

이제야 정답인 코드를 작성했다.

***앞으로 문자열 관련 코딩을 할때는 그냥 넉넉하게 문자열의 크기를 잡아줘야겠다.***

---

# strlen()을 반복문의 조건 안에 집어 넣지 말 것!

추가적으로 하나 알아두면 좋은 점이 있다. 아니, 반드시 코딩을 할 때 유의할 점과 동시에 신경을 써야하는 점이 있다.   

***`strlen()` 함수를 반복문의 조건 안에 집어넣는 것은 하면 안되는 행위이다.***

```cpp
for (int i = 0; i < strlen(str); i++)
```
위와 같이 반복문 안에 `strlen(str)`을 넣게 되면, 반복문이 실행될 때마다 함수를 호출하게 된다.   
이는 매우 비효율적인 코딩을 야기한다.

`strlen()`는 문자열의 끝을 알기 위해 `\0`를 만날 때까지 선형적인 탐색을 하게 된다.   
즉 반복문의 조건문 안에서 또 다른 루프가 돌아가는 것과 마찬가지인 셈인 것이다.

앞으로는 아래와 같이 코딩을 하기로 하자.   
그리고 이러한 점을 항상 염려하기로 하자.
```cpp
int length = strlen(str);
for (int i = 0; i < length); i++)
```


